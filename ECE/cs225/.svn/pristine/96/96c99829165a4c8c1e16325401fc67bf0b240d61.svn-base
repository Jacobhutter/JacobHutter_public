/**
 * @file quadtree.cpp
 * Quadtree class implementation.
 * @date Spring 2008
 */
#include "quadtree.h"
Quadtree::Quadtree(){
 root = NULL;
}

Quadtree::Quadtree(PNG const &source, int resolution){
  root = NULL;
  buildTree(source,resolution);

}
Quadtree::Quadtree(Quadtree const &other){
  //if(other!= NULL)
    root = copy(other.root);
}

Quadtree::QuadtreeNode * Quadtree::copy(QuadtreeNode* const &other){
  if(other == NULL)
      return NULL;
  QuadtreeNode * sub = new QuadtreeNode(other->res, other->x, other->y);
  if(sub == NULL)
    std::cout << " y tho" << endl;
  sub->element = other->element;


    sub->nwChild = copy(other->nwChild);
    sub->neChild = copy(other->neChild);
    sub->swChild = copy(other->swChild);
    sub->seChild = copy(other->seChild);

    return sub;

}

/*Quadtree::QuadtreeNode * Quadtree::rec_fill(QuadtreeNode* const & other){
  if(other == NULL){
    return NULL;
  }

  QuadtreeNode * sub = new QuadtreeNode(other->res, other->x, other->y);
  sub->element = other->element;

  sub->nwChild = rec_fill(other->nwChild);
  sub->neChild = rec_fill(other->neChild);
  sub->swChild = rec_fill(other->swChild);
  sub->seChild = rec_fill(other->seChild);
  return sub;

}*/


Quadtree::~Quadtree(){
  clear();
}

void Quadtree::clear(){
  rec_clr(root);
  //delete this; // delete the quad tree
}

void Quadtree::rec_clr(QuadtreeNode* &leaf){  // post order traversal

  if(leaf == NULL)
    return;

  if(leaf->nwChild != NULL){// nw Child
    rec_clr(leaf->nwChild);
  }

  if(leaf->neChild != NULL){// ne Child
    rec_clr(leaf->neChild);
  }

  if(root->swChild != NULL){ // sw Child
    rec_clr(leaf->swChild);
  }

  if(root->seChild != NULL){// se Child
    rec_clr(leaf->seChild);
  }
 // to get to this point, must have either cleared previous nodes or be a leaf node
  leaf->nwChild = NULL; // cutoff from Children
  leaf->neChild = NULL;
  leaf->swChild = NULL;
  leaf->seChild = NULL;

  delete leaf; // free up memory


}

 Quadtree const & Quadtree::operator=(Quadtree const &other){
   std::cout << "hi ho here we go" << endl;
   if(this != &other){ // check for self assignment
     std::cout << "begin" << endl;
     clear();
     std::cout << "clear wins" << endl;
     /////////////
     root = copy(other.root);
     std::cout << "copy wins" << endl;
     ////////////
   }
     return *this;

}

void Quadtree::buildTree(PNG const &source, int resolution){

    clear(); // delete the current quadtree object;
    root = new QuadtreeNode(resolution,0,0);
    //std::cout << root->res << endl;
    buildTree_rec(source,resolution,root);

}

void Quadtree::buildTree_rec(PNG const &source, int resolution, QuadtreeNode * leaf){
    if(leaf == NULL)
      return;
    if(resolution == 1){
      leaf->element = *source(leaf->x,leaf->y);
      return; // set element color, rest have average
    }


    //std::cout << leaf->x << " " << leaf->y << endl;
    QuadtreeNode * nw = new QuadtreeNode(resolution/2,leaf->x,leaf->y);
    //std::cout << nw->res << " " << nw->x << " " << nw->y << endl;

    QuadtreeNode * ne = new QuadtreeNode(resolution/2,leaf->x+resolution/2,leaf->y);
    //    std::cout << ne->res << " " << ne->x << " " << ne->y << endl;

    QuadtreeNode * sw = new QuadtreeNode(resolution/2,leaf->x,leaf->y+resolution/2);
      //  std::cout << sw->res << " " << sw->x << " " << sw->y << endl;

    QuadtreeNode * se = new QuadtreeNode(resolution/2,leaf->x+resolution/2,leaf->y+resolution/2);
      //  std::cout << se->res << " " << se->x << " " << se->y << endl;

    leaf->nwChild = nw;
    leaf->neChild = ne;
    leaf->swChild = sw;
    leaf->seChild = se;


    buildTree_rec(source, resolution/2, nw); // call on nw
    buildTree_rec(source, resolution/2, ne); // call on ne
    buildTree_rec(source, resolution/2, sw); // call on sw
    buildTree_rec(source, resolution/2, se); // call on se


    uint8_t blue = (leaf->nwChild->element.blue + leaf->neChild->element.blue + leaf->swChild->element.blue + leaf->seChild->element.blue)/4;
    uint8_t green = (leaf->nwChild->element.green + leaf->neChild->element.green + leaf->swChild->element.green + leaf->seChild->element.green)/4;
    uint8_t red = (leaf->nwChild->element.red + leaf->neChild->element.red + leaf->swChild->element.red + leaf->seChild->element.red)/4;
    if (blue > 255 || blue < 0)
      blue = 255;
    if(green > 255 || green < 0)// overflow
      green = 255;
    if(red > 255 || red < 0)
      red = 255;
    leaf->element.blue = blue;
    leaf->element.green = green;
    leaf->element.red = red;

    //leaf->element.blue = (leaf->nwChild->element.blue + leaf->neChild->element.blue + leaf->swChild->element.blue + leaf->seChild->element.blue)/4;
    //leaf->element.green = (leaf->nwChild->element.green + leaf->neChild->element.green + leaf->swChild->element.green + leaf->seChild->element.green)/4;
    //leaf->element.red = (leaf->nwChild->element.red + leaf->neChild->element.red + leaf->swChild->element.red + leaf->seChild->element.red)/4;

}

RGBAPixel Quadtree::getPixel(int x,int y) const{
  if(x < 0 || y < 0)
    return *(new RGBAPixel());
  return getPixel_rec(x, y, root);
}

RGBAPixel Quadtree::getPixel_rec(int x, int y, QuadtreeNode * leaf) const{
  if((x == leaf->x && y == leaf->y && leaf->res == 1))
    return leaf->element;
  if(leaf->nwChild == NULL && leaf->swChild == NULL && leaf->neChild == NULL && leaf->seChild == NULL) // leaf node
    return leaf->element;
  // check boundaries
  if(withinBounds(leaf->nwChild, x, y )){
  RGBAPixel retval =  getPixel_rec(x,y,leaf->nwChild);
    return retval;

  }
  else if(withinBounds(leaf->neChild, x, y )){
      RGBAPixel retval = getPixel_rec(x,y,leaf->neChild);
    return retval;
  }
  else if(withinBounds(leaf->swChild, x, y )){
      RGBAPixel retval = getPixel_rec(x,y,leaf->swChild);
    return retval;
  }
  else {
      RGBAPixel retval = getPixel_rec(x,y,leaf->seChild);
    return retval;
  }


}

bool Quadtree::withinBounds(QuadtreeNode * leaf, int x, int  y) const{
  if(leaf == NULL)
    return false;
  int maxx = leaf->x + leaf->res;
  int minx = leaf->x;

  int maxy = leaf->y + leaf->res;
  int miny = leaf->y;
  if((x >= minx && x< maxx) && (y >= miny && y< maxy))
    return true;
  else
    return false;
}

PNG Quadtree::decompress() const{
  if(root == NULL){
    PNG *a = new PNG();
    return *a;
  }
  PNG *image= new PNG(root->res, root->res); // create new image
  size_t xi,yi;
  xi = 0;
  yi = 0;
  for(xi = 0; xi < image->width(); xi++){
    for(yi = 0; yi < image->height(); yi++){
      *((*image)(xi,yi)) = getPixel(xi,yi);
    }
  }
  return *image;
}

void Quadtree::clockwiseRotate(){

}
void Quadtree::prune(int tolerance){

}
int Quadtree::pruneSize(int tolerance) const{
  return 0;
}
int Quadtree::idealPrune(int numLeaves) const{
  return 0;
}
