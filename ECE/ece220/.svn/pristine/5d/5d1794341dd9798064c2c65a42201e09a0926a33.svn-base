#include "sparsemat.h"

#include <stdio.h>
#include <stdlib.h>


int row_major(int original_row, int original_col, int new_row, int new_col){ // one means switch zero means dont 
 if(original_row > new_row)
 	return 1;
 if(original_row == new_row){
 	if(original_col > new_col)
 		return 1;
 	else
 		return 0;
}
 else 
 	return 0;

}



sp_tuples * load_tuples(char* input_file)
{	
    sp_tuples * new_tuple = (sp_tuples *)malloc(sizeof(sp_tuples));
	new_tuple->tuples_head=NULL;
	double temp = 0;
	int i,j;
	int count=0;
	int * new_address;
	new_address = NULL;
  FILE * fp = fopen(input_file,"r");
		if(fp == NULL){
		printf("FILE COULD NOT BE READ\n");
		return NULL;
}
		fscanf(fp,"%i %i ",&(new_tuple->m),&(new_tuple->n));  // get rows and col
		while(fscanf(fp,"%i %i %lf ",&i,&j,&temp) != EOF){
			//printf("flag\n");
			set_tuples(new_tuple,i,j,temp); 
			//printf("flag2\n");
			if(temp != 0)
			 ++count; 
		}
		new_tuple->nz = count;
		
    return new_tuple; 
}



double gv_tuples(sp_tuples * mat_t,int row,int col)
{	/*	double val=0;
 		sp_tuples_node * cur; // give the value of this node the address of the next 
		cur = mat_t->tuples_head;
		while(cur->row != row && cur->col != col && cur != NULL)
			cur = cur->next; // move to next node in the list 
		val = cur->value;
			
    return val;*/
    return 0;
}



void set_tuples(sp_tuples * mat_t, int row, int col, double value)
{
	if(value == 0){
	return;
}
	else{
		sp_tuples_node * current; //= (sp_tuples_node *)malloc(sizeof(sp_tuples_node));
		if(mat_t->tuples_head==NULL){  //empty list
			current =  (sp_tuples_node *)malloc(sizeof(sp_tuples_node));
			current->row = row;
			current->col = col;
			current->value = value;  // if current node is first then declare it as the head node for now 
			current->next = NULL;
			mat_t->tuples_head = current;
			//printf("initialize\n");
			return;
 		}
 
 		//
 		current = mat_t->tuples_head;
 		sp_tuples_node * follower = (sp_tuples_node *)malloc(sizeof(sp_tuples_node)); // have follower
 		sp_tuples_node * add    = (sp_tuples_node *)malloc(sizeof(sp_tuples_node));
 		add->row = row;
 		add->col = col; // node to be added
 		add->value = value;
 		if(row_major(mat_t->tuples_head->row,mat_t->tuples_head->col,row,col)){ //if current head is bigger than the possible node
 			add->next = mat_t->tuples_head;
 			mat_t->tuples_head = add;
 			//printf("replace head\n");
 			return;
 	}
 		while(current!=NULL){
 		 follower = current;
 		 current = current->next;
 		if(current != NULL){
 		 if(row_major(current->row,current->col,row,col)){  // if we find one that is bigger 
 		 	follower->next = add; // have the following node be the node that points to added
 		 	add->next = current; // have add point to current which is bigger
 		 	//printf("add in middle\n");
 		 	return;
 		 }
 		 }
 	    }
 	    follower->next = add; // have the following node be the node that points to added
 		 	add->next = current; // have add point to current which is bigger
 		 	//if current ends up being null it means our potential add is the biggest on the current list
   
}
	//printf("add to tail\n");
    return;
}


void save_tuples(char * file_name, sp_tuples * mat_t)
{/*	sp_tuples_node * cur;
	//int cur_row = 0;
	//int i;
	//int cur_col = 0;
	int max_cols;
	int max_rows;
	max_cols = mat_t->n; // get matrix columns
	max_rows = mat_t->m; // get matrix rows
	cur = mat_t->tuples_head;
	
		FILE * fp = fopen(file_name,"w");
			if(fp == NULL)
				printf("COULD NOT OPEN FILE\n");
		fprintf(fp,"%i %i\n",max_rows,max_cols);
		while(cur == NULL){
			cur = cur->next; // because current starts off pointing to head	
			if(cur->value != 0){
			fprintf(fp,"%d %d %lf\n",cur->row,cur->col,cur->value);
			}
}
		fclose(fp);*/
	return;
	
}



sp_tuples * add_tuples(sp_tuples * matA, sp_tuples * matB){/*
	sp_tuples * matC = (sp_tuples *)malloc(sizeof(sp_tuples));  // dynamically allocate for matC
	matC->n = matA->n;
	matC->m = matA->m;
	sp_tuples_node * cur1;
	cur1 = matA->tuples_head; // cur1 is just tuples_headA
	sp_tuples_node * cur2;
	while(cur1 != NULL){
		if(cur1->value != 0){
			set_tuples(matC,cur1->row,cur1->col,cur1->value); // add an entry to c where val is just A because b has not been dealt with yet
		}
		cur1 = cur1->next;
}



	cur1 = matB->tuples_head;
	
	
	while(cur1 != NULL){
	 if(cur1->value != 0){
	 	cur2 = matC->tuples_head;
	 	while(cur2 != 0){
	 		if(cur2->col == cur1->col && cur2->row == cur1->row) // we know it is case A + B = C, i.e. tuple in c is already created for this entry
	 			cur2->value = cur1->value +cur2->value; // add together entries
	 		else
	 			set_tuples(matC,cur1->row,cur1->col,cur1->value); // if tuple in c does not exist yet we must add one as to say C = B + 0 for that entry
	 		cur2 = cur2->next;
	 	}
	 }
	 cur1 = cur1->next;
    }
	return matC;
	*/
	return 0;
}



sp_tuples * mult_tuples(sp_tuples * matA, sp_tuples * matB){ /*
	int Arow,Acol;
	sp_tuples * matC = (sp_tuples *)malloc(sizeof(sp_tuples));
	sp_tuples_node * curA = matA->tuples_head;
	sp_tuples_node * curB = matB->tuples_head;
	while(curA != NULL && curA->value != 0){  // find non-zero entries in the list of A 
		Arow = curA->row;
		Acol = curA->col;
		curB = matB->tuples_head;
		while(curB != NULL && curB->row == Acol){
		set_tuples(matC,Arow,curB->col,curA->value*curB->value);
 }
		
	 
	
}
    return matC;
    */
 return 0;
}

void recursive_free(sp_tuples_node * head){
 	if(head == NULL)
		return;
	if(head->next == NULL){
		free(head);
		return;
}
	else
		recursive_free(head->next);
 return;
}
	
void destroy_tuples(sp_tuples * mat_t){
	printf("flag1\n");
	if(mat_t->tuples_head != NULL){
	recursive_free(mat_t->tuples_head);
}
	printf("flag2\n");
	free(mat_t);
    return;
}  






