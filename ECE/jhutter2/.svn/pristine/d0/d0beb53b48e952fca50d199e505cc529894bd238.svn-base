#include <stdio.h>
#include <stdlib.h>
#include "maze.h"
#include <math.h>


/*
 * createMaze -- Creates and fills a maze structure from the given file
 * INPUTS:       fileName - character array containing the name of the maze file
 * OUTPUTS:      None 
 * RETURN:       A filled maze structure that represents the contents of the input file
 * SIDE EFFECTS: None
 */
maze_t * createMaze(char * fileName)
{		int i,j;
    maze_t * newMaze = (maze_t *)malloc(sizeof(maze_t));
		FILE * fp;
		fp = fopen(fileName,"r");	
			if(fp == NULL){
				printf ("file could not be read \n");
			return NULL;
}
		
		fscanf(fp,"%i %i",&(newMaze->width),&(newMaze->height)); // get height and width 
		int mazeSize = newMaze->width * newMaze->height;
		newMaze->cells = (char *)calloc(mazeSize,sizeof(char));
		newMaze->cells = (char *)calloc(mazeSize,sizeof(char));
		for(i = newMaze->height-1;i>=0;i--){
		 for(j = 0;j<newMaze->width;j++){
		 printf("flag\n");
		newMaze->cells[i][j] = fgetc(fp);
		printf("flag\n");
		if(newMaze->cells[i][j] == 'S'){
			newMaze->startRow = i+1;
			newMaze->startColumn = j+1;
   }
		if(newMaze->cells[i][j] == 'E'){
			newMaze->endRow = i+1;
			newMaze->endColumn = j+1;
   }
  }
 }
    return newMaze;
}

/*
 * destroyMaze -- Frees all memory associated with the maze structure, including the structure itself
 * INPUTS:        maze -- pointer to maze structure that contains all necessary information 
 * OUTPUTS:       None
 * RETURN:        None
 * SIDE EFFECTS:  All memory that has been allocated for the maze is freed
 */
void destroyMaze(maze_t * maze)
{
   free(maze->cells);
	 free(maze);
}

/*
 * printMaze --  Prints out the maze in a human readable format (should look like examples)
 * INPUTS:       maze -- pointer to maze structure that contains all necessary information 
 *               width -- width of the maze
 *               height -- height of the maze
 * OUTPUTS:      None
 * RETURN:       None
 * SIDE EFFECTS: Prints the maze to the console
 */
void printMaze(maze_t * maze)
{
    int i,j;
		printf("%i %i",maze->height,maze->width);
		for(i=maze->height-1;i>=0;i--){
			printf("\n");
		 for(j=0;j<maze->width;j++){
			printf("%c",maze->cells[i][j]);
  }
 }
	
}

/*
 * solveMazeManhattanDFS -- recursively solves the maze using depth first search and a manhattan distance heuristic
 * INPUTS:               maze -- pointer to maze structure with all necessary maze information
 *                       col -- the column of the cell currently beinging visited within the maze
 *                       row -- the row of the cell currently being visited within the maze
 * OUTPUTS:              None
 * RETURNS:              0 if the maze is unsolvable, 1 if it is solved
 * SIDE EFFECTS:         Marks maze cells as visited or part of the solution path
 */ 
int solveMazeManhattanDFS(maze_t * maze, int col, int row)
{		int i,set=0,j=0,temp = 0;
    if(col > maze->width-1 || col < 0 || row < 0 || row > maze->height -1)
			return 0;
		if(maze->cells[row][col] == '&' || maze->cells[row][col] == '~')
			return 0;
		if(maze->cells[row][col] == 'E')
			return 1;
		maze->cells[row][col] = '.';
		int Row = maze->endRow;
		int Col = maze->endColumn;
		int MD1,MD2,MD3,MD4;
		
		MD1 = abs((Row)-(row-1))+abs(Col-col);
		MD2 = abs((Row)-(row+1))+abs(Col-col);
		MD3 = abs((Row)-(row))+abs(Col-(col-1));
		MD4 = abs((Row)-(row-1))+abs(Col-(col+1));

		int ARRAY[4] = {MD1,MD2,MD3,MD4};
		while(j<=3){
			for(i = 0; i<=2;i++){
		if(ARRAY[i]>ARRAY[i+1]){
			temp = ARRAY[i];
			ARRAY[i] = ARRAY[i+1];    // sort array, determine L->H array
			ARRAY[i+1] = temp;
	}
 }
++j;
}
  for(i=0;i<=3;i++){
		 if(ARRAY[i] == MD1)
				set = 1;
		if(ARRAY[i] == MD2)
				set = 2;
		if(ARRAY[i] == MD3)
				set = 3;
		if(ARRAY[i] == MD4)
				set = 4;
   switch(set){
      case 1:
			if(solveMazeManhattanDFS(maze,col,row-1)==1)
			return 1;
			break;
			
			case 2:
			if(solveMazeManhattanDFS(maze,col,row+1)==1)
			return 1; 
			break;
			
			case 3:
			if(solveMazeManhattanDFS(maze,col-1,row)==1)
			return 1;
			break;
			
			case 4:if(solveMazeManhattanDFS(maze,col+1,row)==1)
			return 1;
			break;
			
			default:
			break;
	 }
  }  
	maze->cells[row][col] = '~';
    return 0;
}
/*int getPath(maze_t * maze, int col, int row){  // finds path 
if(col > maze->width-1 || col < 0 || row < 0 || row > maze->height -1)
			return 0;
		if(maze->cells[row][col] == '&' || maze->cells[row][col] == '~')
			return 0;
		if(maze->cells[row][col] == 'E')
			return 1;
		maze->cells[row][col] = '.';
		if(solveMazeManhattanDFS(maze,col-1,row)==1)
			return 1; 
		if(solveMazeManhattanDFS(maze,col+1,row)==1)
			return 1;
		if(solveMazeManhattanDFS(maze,col,row+1)==1)
			return 1; 
		if(solveMazeManhattanDFS(maze,col,row-1)==1)
			return 1;
		maze->cells[row][col] = '~';
    // Your code here. Make sure to replace following line with your own code.
    return 0;

}*/
