#include "maze.h"
#include <ctime>
#include <cstdlib>
#include <algorithm>
using namespace std;

SquareMaze::SquareMaze(){
  mazewidth = 0;
  mazeheight = 0;
  cells = std::vector<cell>();
  maze = DisjointSets();
}

void SquareMaze::makeMaze(int width, int height){

  int area = width * height;
  mazewidth = width;
  mazeheight = height;

  // initialize the maze to have area cells

  maze.addelements(area); // add initial area to maze

  srand(time(NULL)); // set random seed

  std::vector <std::pair<std::pair<int,int>,int>> wall_list;

  for(int i = 0; i < height; i++){
    for(int j = 0; j < width; j++){
      cell square;
      square.coordinates = std::pair <int,int>(j,i); //(x,y)
      square.bottom = true;
      square.right = true;
      cells.push_back(square); // add fully walled and coordinated cell onto list of cells
      std::pair<int,int> coor(i,j);
      std::pair<std::pair<int,int>,int> cel1(coor,1);
      std::pair<std::pair<int,int>,int> cel2(coor,0);
      wall_list.push_back(cel1);
      wall_list.push_back(cel2);
    }
  }

while(wall_list.size() != 0){
  int r_width = rand() % width; // choose random width
  int r_height = rand() % height; // choose random height
  int r_wall = rand() % 2; // choose random wall within the random cell
  std::pair<int,int> it(r_width,r_height);
  std::pair<std::pair<int,int>,int> in(it,r_wall);
  size_t i;
  for(i = 0; i < wall_list.size(); i++){
    if(wall_list[i] == in)
      break;
  }
  if( i != wall_list.size()){

    std::pair<std::pair<int,int>,int> temp = wall_list[i];
    wall_list[i] = wall_list[wall_list.size() - 1];
    wall_list[wall_list.size() - 1] = temp;
    wall_list.pop_back();

  if(r_wall == 1 ){ // remove right and check for right edge
    if(  (r_width + 1) % width != 0 ){
    if(maze.find((r_height*width) + r_width) != maze.find((r_height*width) + r_width + 1)){ // cycle detection!

        maze.setunion((r_height*width) + r_width,(r_height*width) + r_width + 1); // union the two sets

        cells[(r_height*width) + r_width].right = false; // reference current cell, remove the desired random wall
     }

   }
  }
  else { // remove bottom
      if ( (r_height + 1) % height != 0 ){ // check for bottom edge

        if(maze.find((r_height * width) + r_width) != maze.find(( (r_height + 1) * width) + r_width )){

          maze.setunion(((r_height * width) + r_width),(( (r_height + 1) * width) + r_width )); // join top and bottom cells

          cells[(r_height*width) + r_width].bottom = false; // remove bottom wall of desired random type
        }
      }
  }


  }
 }

}
bool SquareMaze::canTravel(int x, int y, int dir) const{
  cell cur;
  size_t i = y*mazewidth + x;
  cur = cells[i];
//  cout << " cell index:" << i << endl;
//  cout << " cell coordinates: " << cells[i].coordinates.first << cells[i].coordinates.second << endl;
//  cout << " x & y : " << x << y << endl;
//  cout << "direction: " << dir << endl;
  if(dir == 0 && cur.coordinates.first + 1 != mazewidth && cur.right == 0){ // right
  //  cout << "right!" << endl;
    return true;
  }
  if(dir == 1 && cur.coordinates.second + 1 != mazeheight && cur.bottom == 0){ // down
  //  cout << "down!" << endl;
    return true;
  }
  if(dir == 2 && cur.coordinates.first != 0 && cells[i-1].right == 0){// left
  //  cout << "left!" << endl;
    return true;
  }
  if(dir == 3 && cur.coordinates.second != 0 && cells[i-mazewidth].bottom == 0){ // up
  //  cout << "up!" << endl;
    return true;
  }
  //cout << "can't move in " << dir << " direction" << endl;
  return false;
}
void SquareMaze::setWall(int x, int y, int dir, bool exists){}
vector<int> SquareMaze::solveMaze(){
  return vector<int>();
}
PNG * SquareMaze::drawMaze() const{
  /*for(size_t i =0; i < cells.size(); i++){
    if(cells[i].bottom)
      cout << "_";
    else
      cout << " ";
    if(cells[i].right)
      cout << "|";
    else
      cout << " ";
    if(i == 1)
      cout << endl;
  }
    cout << endl;
  maze.printsets();*/
  PNG * a = new PNG();
  return a;
}
PNG * SquareMaze::drawMazeWithSolution(){
  PNG * a = new PNG();
  return a;
}
