GDT
* Global Descriptor Table
* Used to emulate an Intel IA-32 processor
* Contains:
   * Kernel Code Segment
   * Kernel Data Segment
   * User Code Segment
   * Data Code Segment
* lgdtr
   * asm command to load gdtr, required for bootup


IDT
* Interrupt Descriptor Table
* Exceptions set up with DPL 0, sys calls with DPL 3. 
* Setting gates using idt[i] vs setting idt entry with SET_IDT_ENTRY
* Routes hardware exception gate to assembly wrapper 
* Entry at 0x80 for System Calls


Assembly wrapper
* uses jump table format to route to push all registers, call c function and then return registers to normal state and continue program.


I8259
* enable irq updates global mask and applies it to IRQ pins to mask interrupts from unregistered inputs
     -     send EOI ends the pic interrupt to allow that IRQ pin to fire again, in master use direct eoi to that irq, if slave needed then eoi sent to irq2 and corresponding slave irq
     -     init: masks all pic interrupts, then outputs the control words to master and slave lines and corresponding data lines




Paging
* Used to Prevent fragmentation
* Can be 4kB or 4MB
* Kernel - 4MB Page @ 4MB (4MB-8MB)
* Multiple virtual addresses can point to same physical address
* cr3 - holds pointer to page directory
* cr2  - holds address that caused page fault
* cr0 bit 31 - enables or disables paging
* cr4 bit 4 - enables of disables page extension (4MB pages)
* 1 page directory, 2 page tables
   * Page table #1 is used to map to physical video memory (VID_MEM)
   * Page table #2 is used to map user vidmem addresses to frame buffers in kernel memory


Terminal Driver
* Writes to that terminals frame_buffer mapped to a page within kernel space. 
* Frame buffer copied to vga mem consistently after keypress
* Switching terminals initiates context switch 
* Size of keyboard buffer is 128 Characters
* Scrolling works by shifting video memory upwards


Read-Only File system
* Flat file system (only one directory)
* 4kB blocks
* Dentry
   * Gives inode, filename, and file type
* Boot block
   * 1st dentry tells how many dir entries, number of inodes, and number of data blocks
   * 64 dentries
      * 1 for file system info
      * 1 for directory
      * 62 files
* Inodes
   * 4B for length of file
   * Following 4B blocks point to data blocks
* Data block
   * Holds data in Bytes


Real-Time Clock
* Check GitLab wiki for detailed description of what each bit does
* Uses similar syscalls as a file
* File position indicates index of clock in kernel array of clocks to access
* OPEN syscall allocates an RTC clock set to 2 Hz
* READ syscall forces process to wait for next virtual tick at the specified frequency
   * Virtual tick - interrupt simulated by the kernel
   * Real tick - hardware interrupt sent by the RTC hardware itself
* WRITE syscall changes the frequency of clock allocated to process
* CLOSE de-allocates clock
* We virtualize the RTC by setting the clock frequency to 1024 Hz and allocating an array to count the number of real ticks coming from the RTC
* For each clock allocated to a process, we count the appropriate amount of ticks from the RTC to simulate a frequency
   * When the amount of ticks reaches 1024 / freq, we lower a flag if it’s set in the rtc_read function and reset the counter
      * This would allow the corresponding process to proceed in the READ call
   * This works because all of the valid frequencies supported are powers of two less than 1024 Hz i.e. all of the frequencies are factors of 1024, so they can be counted by an integer number of real ticks


System Calls
* Execute: parse args, check elf, enable the user page, load program elf into memory, setup pcb, 8kb align pcb, setup tss ss0 and esp. Context switch 
* Halt: check for head process, mark process mask as omitting that process’ id. Retrieve old esp ebp from current pcb, return to that esp ebp 
* Vidmap: map 136 mb + 4,8,12 kb to frame buf 1 2 3 in kernel space  


Loader
* Check ELF to make sure it’s an executable
* Get entry point at bytes 24-27
* Copy program to virtual address 0x08048000


Executing User-Level Code
* Uses an x86-specific convention to accomplish a Privilege Switch
   * Use of IRET


Process Control Block
* Per-task data structure
* Gives description of current process.
   * process number
   * Parent process
   * Esp, ebp
   * File descriptor table
   * Terminal
   * Arguments 
* Aligned to 8kB above the process.


Scheduling
* GOAL: Set up three shells without delay at bootup
* At the beginning of the bootup process, right before we execute the first shell, we set a flag variable to wait for a PIT interrupt.
* The PIT interrupt fires, entering the handler function which
   * Creates two copies of the current kernel stack and mounts them 8KB and 16KB above the current kernel stack
   * Sets up task_t data structure information for all three initial shells
   * The task data should essentially be 8KB/16KB shifted versions of each other
   * The PIT lowers the flag variable to allow the first process to reach execute(“shell”)
* Subsequent interrupts by the PIT will
   * Store current ESP, EBP, TSS.ESP0 into the task_t structure
   * Switch to the next task in the circular list
   * Set ESP, EBP, TSS.ESP0 to the values stored in the next task_t struct
   * Change page_directory entry #32 to change virtual address of a user program to point to the starting address of the next program in the task
   * Request to update the terminal - fulfilled if current terminal index matches process index to be serviced
* Advantages of this approach
   * Avoid increasing complexity of state transitions when switching terminals - a terminal switch would not need to check to see if a new shell needs to be spawned
   * Avoid duplicating the EXECUTE system call - all three concurrent tasks would use the same entry point in kernel.c to create a new shell


Multiple Tasks
* All pcb’s are located on stack 8kb aligned. Scheduling pulls the next one on the list of three active options. Tasks are not discriminated by terminal but do have their own respective terminals 


Stack Switching
* Esp ebp are stored into current pcb, tss is updated and context switch is initiated between the next task in the list


TSS
* Task state segment, esp0 and ss0 are referenced when switching from ring 0 to 3, kernel to user space 


Memory Map
* Every program gets mapped to 128MB.
* First program (shell) is at 8MB in physical memory, each subsequent process gets put at 4MB down